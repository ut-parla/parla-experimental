\hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence}{}\doxysection{parla.\+common.\+parray.\+coherence.\+Coherence Class Reference}
\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence}\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a31ad62ae4f18a5c4758ab078ad737ed1}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, int init\+\_\+owner, int num\+\_\+gpu, Cy\+PArray\+State cyparray\+\_\+state)
\item 
def \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ad74ae936252243b5457f5239961bdbba}{reset}} (self, int new\+\_\+owner)
\item 
List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a56fa655ef59e928066e435969a5f24a6}{read}} (self, int device\+\_\+id, int slices\+\_\+hash=None)
\item 
List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2095bb13a7452502292d7777d68a6828}{write}} (self, int device\+\_\+id, int slices\+\_\+hash=None)
\item 
List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_adbaacdb833acadb063ac618a7b00a4ca}{evict}} (self, int device\+\_\+id, bool keep\+\_\+one\+\_\+copy=True)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a64860ee1101484eda6d85f88fe54186b}{owner}}
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a790c9623a24f7ad2b8a81945751959d8}{INVALID}} = 0
\item 
int \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ab4bf22d2fb6e3497a05f31b046288d26}{SHARED}} = 1
\item 
int \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a66d670594be720ef3f31d01fb3a5e780}{MODIFIED}} = 2
\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a31910a7d72b01c754c6450d28a0344ae}{\+\_\+owner\+\_\+is\+\_\+latest}} (self)
\item 
List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} \mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2af383e43f6f43ef48077e8e7aef7db6}{\+\_\+write\+\_\+back\+\_\+to}} (self, int device\+\_\+id, int new\+\_\+state, bool on\+\_\+different\+\_\+device=False, int this\+\_\+device\+\_\+id=None)
\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a76699d6bbc8fcc5c681eabb8900d9596}{\+\_\+local\+\_\+states}}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a0e6c612937b2e7aaaa0644be15443118}{\+\_\+versions}}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_afc7961eea4c23bb6addd772c4d1b1774}{\+\_\+is\+\_\+complete}}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ab805678c6c7fae95deb305f6df7f45f2}{\+\_\+latest\+\_\+version}}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a142ce1b3c9cd44ed5673ac6807b6552a}{\+\_\+lock}}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a5eac154e32a3306e30ced424ce5662bb}{\+\_\+cyparray\+\_\+state}}
\item 
\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a58492eb01469b98a98756fc737d59b51}{\+\_\+global\+\_\+state}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Implements fine-grained MSI protocol.

Each copy could be a subarray of a complete copy
Assumption: all valid subarray are disjoint
\end{DoxyVerb}
 

Definition at line 70 of file coherence.\+py.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a31ad62ae4f18a5c4758ab078ad737ed1}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a31ad62ae4f18a5c4758ab078ad737ed1}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int}]{init\+\_\+owner,  }\item[{int}]{num\+\_\+gpu,  }\item[{Cy\+PArray\+State}]{cyparray\+\_\+state }\end{DoxyParamCaption})}

\begin{DoxyVerb}Args:
    init_owner: the owner of the first copy in the system
    num_gpu: number of GPU devices in the system
\end{DoxyVerb}
 

Definition at line 89 of file coherence.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{89     \textcolor{keyword}{def }\mbox{\hyperlink{namespaceparla_1_1cython_1_1core_abd75527c775e8a2eda6c2bd84fc0761a}{\_\_init\_\_}}(self, init\_owner: int, num\_gpu: int, cyparray\_state: CyPArrayState): }
\DoxyCodeLine{90         \textcolor{stringliteral}{"{}"{}"{} }}
\DoxyCodeLine{91 \textcolor{stringliteral}{        Args: }}
\DoxyCodeLine{92 \textcolor{stringliteral}{            init\_owner: the owner of the first copy in the system }}
\DoxyCodeLine{93 \textcolor{stringliteral}{            num\_gpu: number of GPU devices in the system }}
\DoxyCodeLine{94 \textcolor{stringliteral}{        "{}"{}"{}} }
\DoxyCodeLine{95         \textcolor{comment}{\# If copy is complete, value is state }}
\DoxyCodeLine{96         \textcolor{comment}{\# if not, value is a Dict\{slices\_hash: state\} }}
\DoxyCodeLine{97         self.\_local\_states = \{n: self.INVALID \textcolor{keywordflow}{for} n \textcolor{keywordflow}{in} range(num\_gpu)\}  \textcolor{comment}{\# init GPU status }}
\DoxyCodeLine{98         self.\_local\_states[CPU\_INDEX] = self.INVALID                    \textcolor{comment}{\# init CPU status }}
\DoxyCodeLine{99  }
\DoxyCodeLine{100         \textcolor{comment}{\# If copy is complete, value is version }}
\DoxyCodeLine{101         \textcolor{comment}{\# if not, value is a Dict\{slices\_hash: version\} }}
\DoxyCodeLine{102         self.\_versions = \{n: -\/1 \textcolor{keywordflow}{for} n \textcolor{keywordflow}{in} range(num\_gpu)\}    \textcolor{comment}{\# init copy version (-\/1 means no data) }}
\DoxyCodeLine{103         self.\_versions[CPU\_INDEX] = -\/1 }
\DoxyCodeLine{104  }
\DoxyCodeLine{105         \textcolor{comment}{\# fields used to support fine grained data movement }}
\DoxyCodeLine{106         self.\_is\_complete = \{n: \textcolor{keywordtype}{None} \textcolor{keywordflow}{for} n \textcolor{keywordflow}{in} range(num\_gpu)\}  \textcolor{comment}{\# does the device own a complete copy? None means neither }}
\DoxyCodeLine{107         self.\_is\_complete[CPU\_INDEX] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{108  }
\DoxyCodeLine{109         self.\_local\_states[init\_owner] = self.MODIFIED      \textcolor{comment}{\# initial state is MODIFIED }}
\DoxyCodeLine{110         self.owner = init\_owner                             \textcolor{comment}{\# the device that has the complete copy (take the role of main memory) }}
\DoxyCodeLine{111         self.\_versions[init\_owner] = 0                      \textcolor{comment}{\# the first version is 0 }}
\DoxyCodeLine{112         self.\_is\_complete[init\_owner] = \textcolor{keyword}{True}                \textcolor{comment}{\# the copy is complete }}
\DoxyCodeLine{113         self.\_latest\_version = 0                            \textcolor{comment}{\# the latest version in the system }}
\DoxyCodeLine{114  }
\DoxyCodeLine{115         \textcolor{comment}{\# held the lock when updating states }}
\DoxyCodeLine{116         self.\_lock = threading.Lock() }
\DoxyCodeLine{117  }
\DoxyCodeLine{118         self.\_cyparray\_state = cyparray\_state }
\DoxyCodeLine{119         self.\_cyparray\_state.set\_valid\_on\_device(init\_owner, \textcolor{keyword}{True}) }
\DoxyCodeLine{120  }

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a31910a7d72b01c754c6450d28a0344ae}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a31910a7d72b01c754c6450d28a0344ae}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_owner\_is\_latest@{\_owner\_is\_latest}}
\index{\_owner\_is\_latest@{\_owner\_is\_latest}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_owner\_is\_latest()}{\_owner\_is\_latest()}}
{\footnotesize\ttfamily  bool parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+owner\+\_\+is\+\_\+latest (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

\begin{DoxyVerb}True if owner's has latest version\end{DoxyVerb}
 

Definition at line 138 of file coherence.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{138     \textcolor{keyword}{def }\_owner\_is\_latest(self) -\/> bool: }
\DoxyCodeLine{139         \textcolor{stringliteral}{"{}"{}"{}True if owner's has latest version"{}"{}"{}} }
\DoxyCodeLine{140         \textcolor{keywordflow}{return} self.\_versions[self.owner] == self.\_latest\_version }
\DoxyCodeLine{141  }

\end{DoxyCode}


References parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+latest\+\_\+version, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+versions, and parla.\+common.\+parray.\+coherence.\+Coherence.\+owner.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a31910a7d72b01c754c6450d28a0344ae_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2af383e43f6f43ef48077e8e7aef7db6}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2af383e43f6f43ef48077e8e7aef7db6}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_write\_back\_to@{\_write\_back\_to}}
\index{\_write\_back\_to@{\_write\_back\_to}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_write\_back\_to()}{\_write\_back\_to()}}
{\footnotesize\ttfamily  List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int}]{device\+\_\+id,  }\item[{int}]{new\+\_\+state,  }\item[{bool }]{on\+\_\+different\+\_\+device = {\ttfamily False},  }\item[{int }]{this\+\_\+device\+\_\+id = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

\begin{DoxyVerb}Generate the list of write back MemoryOperation.
Which make `device_id` has the latest version with a complete copy.

Args:
    device_id: id of dst device (where writeback to)
    new_state: new state of `dcvice_id`
    on_different_device: True if this device is not current deivce
    this_device_id: if `on_different_device` is True, this means current device ID. If None, ignore

Return:
    operations, has_copy (true if need to copy data to the device)

Note: version will be updated
\end{DoxyVerb}
 

Definition at line 142 of file coherence.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{143                        this\_device\_id: int = \textcolor{keywordtype}{None}) -\/> List[MemoryOperation]: }
\DoxyCodeLine{144         \textcolor{stringliteral}{"{}"{}"{} }}
\DoxyCodeLine{145 \textcolor{stringliteral}{        Generate the list of write back MemoryOperation. }}
\DoxyCodeLine{146 \textcolor{stringliteral}{        Which make `device\_id` has the latest version with a complete copy. }}
\DoxyCodeLine{147 \textcolor{stringliteral}{ }}
\DoxyCodeLine{148 \textcolor{stringliteral}{        Args: }}
\DoxyCodeLine{149 \textcolor{stringliteral}{            device\_id: id of dst device (where writeback to) }}
\DoxyCodeLine{150 \textcolor{stringliteral}{            new\_state: new state of `dcvice\_id` }}
\DoxyCodeLine{151 \textcolor{stringliteral}{            on\_different\_device: True if this device is not current deivce }}
\DoxyCodeLine{152 \textcolor{stringliteral}{            this\_device\_id: if `on\_different\_device` is True, this means current device ID. If None, ignore }}
\DoxyCodeLine{153 \textcolor{stringliteral}{ }}
\DoxyCodeLine{154 \textcolor{stringliteral}{        Return: }}
\DoxyCodeLine{155 \textcolor{stringliteral}{            operations, has\_copy (true if need to copy data to the device) }}
\DoxyCodeLine{156 \textcolor{stringliteral}{ }}
\DoxyCodeLine{157 \textcolor{stringliteral}{        Note: version will be updated }}
\DoxyCodeLine{158 \textcolor{stringliteral}{        "{}"{}"{}} }
\DoxyCodeLine{159         \textcolor{comment}{\# write back copies that }}
\DoxyCodeLine{160         \textcolor{comment}{\# 1. not INVALID (INVALID copy already write back to owner when it get invalidate) }}
\DoxyCodeLine{161         \textcolor{comment}{\# 2. has higher version than owner's }}
\DoxyCodeLine{162         current\_version = self.\_versions[device\_id] }
\DoxyCodeLine{163         target = set() \textcolor{comment}{\# a tuple of (version, device\_id) }}
\DoxyCodeLine{164         latest\_complete\_copy\_id = \textcolor{keywordtype}{None} }
\DoxyCodeLine{165         latest\_complete\_version = -\/1 }
\DoxyCodeLine{166         evict\_list = [] }
\DoxyCodeLine{167  }
\DoxyCodeLine{168         \textcolor{keywordflow}{for} id, state \textcolor{keywordflow}{in} self.\_local\_states.items(): }
\DoxyCodeLine{169             \textcolor{keywordflow}{if} isinstance(state, dict):  \textcolor{comment}{\# subarray need to write back }}
\DoxyCodeLine{170                 target.add(id) }
\DoxyCodeLine{171  }
\DoxyCodeLine{172                 \textcolor{keywordflow}{if} new\_state == self.MODIFIED: }
\DoxyCodeLine{173                     \textcolor{comment}{\# invalidate all subarray }}
\DoxyCodeLine{174                     self.\_local\_states[id] = self.INVALID }
\DoxyCodeLine{175                     self.\_cyparray\_state.set\_valid\_on\_device(id, \textcolor{keyword}{False}) }
\DoxyCodeLine{176                     self.\_versions[id] = -\/1 }
\DoxyCodeLine{177                     self.\_is\_complete[id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{178                     evict\_list.append(id) }
\DoxyCodeLine{179                 \textcolor{keywordflow}{else}: }
\DoxyCodeLine{180                     \textcolor{comment}{\# change all states to SHARED }}
\DoxyCodeLine{181                     \textcolor{keywordflow}{for} hash, state \textcolor{keywordflow}{in} self.\_local\_states[id].items(): }
\DoxyCodeLine{182                         self.\_local\_states[id][hash] = self.SHARED }
\DoxyCodeLine{183                     self.\_cyparray\_state.set\_valid\_on\_device(id, \textcolor{keyword}{True}) }
\DoxyCodeLine{184             \textcolor{keywordflow}{else}:  \textcolor{comment}{\# write back the latest complete array }}
\DoxyCodeLine{185                 \textcolor{keywordflow}{if} self.\_versions[id] >= latest\_complete\_version: }
\DoxyCodeLine{186                     latest\_complete\_version = self.\_versions[id] }
\DoxyCodeLine{187                     latest\_complete\_copy\_id = id }
\DoxyCodeLine{188  }
\DoxyCodeLine{189                 \textcolor{comment}{\# downgrade }}
\DoxyCodeLine{190                 \textcolor{keywordflow}{if} id != device\_id: }
\DoxyCodeLine{191                     \textcolor{keywordflow}{if} self.\_local\_states[id] == self.SHARED: }
\DoxyCodeLine{192                         \textcolor{keywordflow}{if} new\_state == self.MODIFIED: }
\DoxyCodeLine{193                             self.\_local\_states[id] = self.INVALID }
\DoxyCodeLine{194                             self.\_cyparray\_state.set\_valid\_on\_device(id, \textcolor{keyword}{False}) }
\DoxyCodeLine{195                             self.\_versions[id] = -\/1 }
\DoxyCodeLine{196                             self.\_is\_complete[id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{197                             evict\_list.append(id) }
\DoxyCodeLine{198                     \textcolor{keywordflow}{elif} self.\_local\_states[id] == self.MODIFIED: }
\DoxyCodeLine{199                         \textcolor{keywordflow}{if} new\_state == self.SHARED: }
\DoxyCodeLine{200                             self.\_local\_states[id] = self.SHARED }
\DoxyCodeLine{201                             self.\_cyparray\_state.set\_valid\_on\_device(id, \textcolor{keyword}{True}) }
\DoxyCodeLine{202                         \textcolor{keywordflow}{elif} new\_state == self.MODIFIED: }
\DoxyCodeLine{203                             self.\_local\_states[id] = self.INVALID }
\DoxyCodeLine{204                             self.\_cyparray\_state.set\_valid\_on\_device(id, \textcolor{keyword}{False}) }
\DoxyCodeLine{205                             self.\_versions[id] = -\/1 }
\DoxyCodeLine{206                             self.\_is\_complete[id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{207                             evict\_list.append(id) }
\DoxyCodeLine{208  }
\DoxyCodeLine{209         \textcolor{keywordflow}{if} latest\_complete\_copy\_id \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}: }
\DoxyCodeLine{210             \textcolor{keywordflow}{raise} RuntimeError(\textcolor{stringliteral}{"{}There is no valid complete copy"{}}) }
\DoxyCodeLine{211  }
\DoxyCodeLine{212         \textcolor{keywordflow}{if} new\_state == self.MODIFIED: }
\DoxyCodeLine{213             evict\_list += list(target) }
\DoxyCodeLine{214  }
\DoxyCodeLine{215             \textcolor{comment}{\# `this\_device\_id` is the device id of the final destionation }}
\DoxyCodeLine{216             \textcolor{comment}{\# so should write it back but not evict it }}
\DoxyCodeLine{217             \textcolor{keywordflow}{if} this\_device\_id \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}: }
\DoxyCodeLine{218                 evict\_list.remove(this\_device\_id) }
\DoxyCodeLine{219  }
\DoxyCodeLine{220         \textcolor{keywordflow}{if} current\_version < latest\_complete\_version: }
\DoxyCodeLine{221             target = [latest\_complete\_copy\_id] + list(target)  \textcolor{comment}{\# complete copy first }}
\DoxyCodeLine{222  }
\DoxyCodeLine{223         \textcolor{comment}{\# update latest version }}
\DoxyCodeLine{224         self.\_versions[device\_id] = self.\_latest\_version }
\DoxyCodeLine{225         \textcolor{keywordflow}{return} [MemoryOperation.load(device\_id, t, on\_different\_device=on\_different\_device) \textcolor{keywordflow}{for} t \textcolor{keywordflow}{in} target] \(\backslash\) }
\DoxyCodeLine{226                + [MemoryOperation.evict(t) \textcolor{keywordflow}{for} t \textcolor{keywordflow}{in} evict\_list] }
\DoxyCodeLine{227  }

\end{DoxyCode}


References parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+core.\+PArray.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+is\+\_\+complete, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+latest\+\_\+version, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+local\+\_\+states, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+versions, parla.\+common.\+globals.\+Device\+Type.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+MODIFIED, and parla.\+common.\+parray.\+coherence.\+Coherence.\+SHARED.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2af383e43f6f43ef48077e8e7aef7db6_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_adbaacdb833acadb063ac618a7b00a4ca}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_adbaacdb833acadb063ac618a7b00a4ca}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!evict@{evict}}
\index{evict@{evict}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{evict()}{evict()}}
{\footnotesize\ttfamily  List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} parla.\+common.\+parray.\+coherence.\+Coherence.\+evict (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int}]{device\+\_\+id,  }\item[{bool }]{keep\+\_\+one\+\_\+copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb} Tell the protocol that this device want to clear the copy.
Args:
    device_id: id of this device
    keep_one_copy: if true, writeback the last copy to CPU
Return:
    List[MemoryOperation], could return several MemoryOperations.
        And the order operations matter.
Note: if this device has the last copy and `keep_one_copy` is false, 
    the whole protocol state will be INVALID then.
    And the system will lose the copy. Be careful when evict the last copy.
\end{DoxyVerb}
 

Definition at line 451 of file coherence.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{451     \textcolor{keyword}{def }evict(self, device\_id: int, keep\_one\_copy: bool = \textcolor{keyword}{True}) -\/> List[MemoryOperation]: }
\DoxyCodeLine{452         \textcolor{stringliteral}{"{}"{}"{} Tell the protocol that this device want to clear the copy. }}
\DoxyCodeLine{453 \textcolor{stringliteral}{        Args: }}
\DoxyCodeLine{454 \textcolor{stringliteral}{            device\_id: id of this device }}
\DoxyCodeLine{455 \textcolor{stringliteral}{            keep\_one\_copy: if true, writeback the last copy to CPU }}
\DoxyCodeLine{456 \textcolor{stringliteral}{        Return: }}
\DoxyCodeLine{457 \textcolor{stringliteral}{            List[MemoryOperation], could return several MemoryOperations. }}
\DoxyCodeLine{458 \textcolor{stringliteral}{                And the order operations matter. }}
\DoxyCodeLine{459 \textcolor{stringliteral}{        Note: if this device has the last copy and `keep\_one\_copy` is false,  }}
\DoxyCodeLine{460 \textcolor{stringliteral}{            the whole protocol state will be INVALID then. }}
\DoxyCodeLine{461 \textcolor{stringliteral}{            And the system will lose the copy. Be careful when evict the last copy. }}
\DoxyCodeLine{462 \textcolor{stringliteral}{        "{}"{}"{}} }
\DoxyCodeLine{463         device\_local\_state = self.\_local\_states[device\_id] }
\DoxyCodeLine{464         operations = [] }
\DoxyCodeLine{465         evict\_last\_copy = \textcolor{keyword}{False} }
\DoxyCodeLine{466  }
\DoxyCodeLine{467         \textcolor{keywordflow}{if} device\_local\_state == self.INVALID: \textcolor{comment}{\# already evicted, do nothing }}
\DoxyCodeLine{468             operations.append(MemoryOperation.noop()) }
\DoxyCodeLine{469         \textcolor{keywordflow}{elif} device\_local\_state == self.SHARED: }
\DoxyCodeLine{470             \textcolor{keywordflow}{if} device\_id == self.owner:  \textcolor{comment}{\# has a chance this is the last copy }}
\DoxyCodeLine{471                 \textcolor{comment}{\# find new owner }}
\DoxyCodeLine{472                 new\_owner = \textcolor{keywordtype}{None} }
\DoxyCodeLine{473                 \textcolor{keywordflow}{for} device, state \textcolor{keywordflow}{in} self.\_local\_states.items(): }
\DoxyCodeLine{474                     \textcolor{keywordflow}{if} state == self.SHARED \textcolor{keywordflow}{and} device != device\_id:  \textcolor{comment}{\# should not include this device itself }}
\DoxyCodeLine{475                         new\_owner = device }
\DoxyCodeLine{476                         \textcolor{keywordflow}{break} }
\DoxyCodeLine{477  }
\DoxyCodeLine{478                 \textcolor{comment}{\# this device owns the last copy }}
\DoxyCodeLine{479                 \textcolor{keywordflow}{if} new\_owner \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}: }
\DoxyCodeLine{480                     evict\_last\_copy = \textcolor{keyword}{True} }
\DoxyCodeLine{481             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{482                 \textcolor{comment}{\# update states }}
\DoxyCodeLine{483                 self.\_local\_states[device\_id] = self.INVALID }
\DoxyCodeLine{484                 self.\_versions[device\_id] = -\/1 }
\DoxyCodeLine{485                 self.\_is\_complete[device\_id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{486  }
\DoxyCodeLine{487                 operations.append(MemoryOperation.evict(device\_id)) }
\DoxyCodeLine{488         \textcolor{keywordflow}{else}:  \textcolor{comment}{\# Modified, this device owns the last copy }}
\DoxyCodeLine{489             evict\_last\_copy = \textcolor{keyword}{True} }
\DoxyCodeLine{490  }
\DoxyCodeLine{491         \textcolor{keywordflow}{if} evict\_last\_copy: }
\DoxyCodeLine{492             \textcolor{keywordflow}{if} keep\_one\_copy:  \textcolor{comment}{\# write back to CPU }}
\DoxyCodeLine{493                 \textcolor{keywordflow}{if} device\_id != CPU\_INDEX:               }
\DoxyCodeLine{494                     operations.extend(self.\_write\_back\_to(CPU\_INDEX, self.MODIFIED, on\_different\_device=\textcolor{keyword}{True}, this\_device\_id=device\_id)) }
\DoxyCodeLine{495  }
\DoxyCodeLine{496                     self.owner = CPU\_INDEX }
\DoxyCodeLine{497                     self.\_local\_states[CPU\_INDEX] = self.MODIFIED }
\DoxyCodeLine{498                     self.\_is\_complete[device\_id] = \textcolor{keyword}{True} }
\DoxyCodeLine{499                 \textcolor{keywordflow}{else}: }
\DoxyCodeLine{500                     \textcolor{keywordflow}{return} [MemoryOperation.noop()] }
\DoxyCodeLine{501             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{502                 self.\_global\_state = self.INVALID  \textcolor{comment}{\# the system lose the last copy }}
\DoxyCodeLine{503                 self.owner = \textcolor{keywordtype}{None} }
\DoxyCodeLine{504                 self.\_versions[device\_id] = -\/1 }
\DoxyCodeLine{505                 self.\_is\_complete[device\_id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{506  }
\DoxyCodeLine{507                 self.\_local\_states[device\_id] = self.INVALID }
\DoxyCodeLine{508                 operations.append(MemoryOperation.evict(device\_id)) }
\DoxyCodeLine{509  }
\DoxyCodeLine{510         \textcolor{keywordflow}{return} operations }

\end{DoxyCode}


References parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+is\+\_\+complete, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+local\+\_\+states, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+versions, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+globals.\+Device\+Type.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+MODIFIED, parla.\+common.\+parray.\+coherence.\+Coherence.\+owner, and parla.\+common.\+parray.\+coherence.\+Coherence.\+SHARED.

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_adbaacdb833acadb063ac618a7b00a4ca_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a56fa655ef59e928066e435969a5f24a6}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a56fa655ef59e928066e435969a5f24a6}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!read@{read}}
\index{read@{read}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{read()}{read()}}
{\footnotesize\ttfamily  List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} parla.\+common.\+parray.\+coherence.\+Coherence.\+read (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int}]{device\+\_\+id,  }\item[{int }]{slices\+\_\+hash = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb} Tell the protocol that this device read from the copy.

Args:
    device_id: id of this device
    slices_hash: hash code of the slices of the subarray to be manipulated
                 by default equals to None, which means the whole array is manipulated

Return:
    List[MemoryOperation], which tell how data will be manipulated, and order matter.
    
Note: lock will be acquired
\end{DoxyVerb}
 

Definition at line 228 of file coherence.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{228     \textcolor{keyword}{def }read(self, device\_id: int, slices\_hash: int = \textcolor{keywordtype}{None}) -\/> List[MemoryOperation]: }
\DoxyCodeLine{229         \textcolor{stringliteral}{"{}"{}"{} Tell the protocol that this device read from the copy. }}
\DoxyCodeLine{230 \textcolor{stringliteral}{ }}
\DoxyCodeLine{231 \textcolor{stringliteral}{        Args: }}
\DoxyCodeLine{232 \textcolor{stringliteral}{            device\_id: id of this device }}
\DoxyCodeLine{233 \textcolor{stringliteral}{            slices\_hash: hash code of the slices of the subarray to be manipulated }}
\DoxyCodeLine{234 \textcolor{stringliteral}{                         by default equals to None, which means the whole array is manipulated }}
\DoxyCodeLine{235 \textcolor{stringliteral}{ }}
\DoxyCodeLine{236 \textcolor{stringliteral}{        Return: }}
\DoxyCodeLine{237 \textcolor{stringliteral}{            List[MemoryOperation], which tell how data will be manipulated, and order matter. }}
\DoxyCodeLine{238 \textcolor{stringliteral}{             }}
\DoxyCodeLine{239 \textcolor{stringliteral}{        Note: lock will be acquired }}
\DoxyCodeLine{240 \textcolor{stringliteral}{        "{}"{}"{}} }
\DoxyCodeLine{241         operations = [] }
\DoxyCodeLine{242  }
\DoxyCodeLine{243         \textcolor{keywordflow}{if} slices\_hash \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}: \textcolor{comment}{\# move a subarray }}
\DoxyCodeLine{244             \textcolor{keywordflow}{if} self.\_is\_complete[device\_id] \textcolor{keywordflow}{is} \textcolor{keyword}{True}:  \textcolor{comment}{\# use existing complete data at this device }}
\DoxyCodeLine{245                 device\_local\_state = self.\_local\_states[device\_id] }
\DoxyCodeLine{246             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{247                 \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(self.\_local\_states[device\_id], dict): }
\DoxyCodeLine{248                     self.\_versions[device\_id] = \{\} }
\DoxyCodeLine{249                     self.\_local\_states[device\_id] = \{\} }
\DoxyCodeLine{250                     device\_local\_state = self.INVALID }
\DoxyCodeLine{251                 \textcolor{keywordflow}{elif} slices\_hash \textcolor{keywordflow}{in} self.\_local\_states[device\_id]: }
\DoxyCodeLine{252                     device\_local\_state = self.\_local\_states[device\_id][slices\_hash] }
\DoxyCodeLine{253                 \textcolor{keywordflow}{else}: }
\DoxyCodeLine{254                     device\_local\_state = self.INVALID }
\DoxyCodeLine{255                 self.\_is\_complete[device\_id] = \textcolor{keyword}{False}  \textcolor{comment}{\# this is a subarray }}
\DoxyCodeLine{256         \textcolor{keywordflow}{elif} self.\_is\_complete[device\_id] \textcolor{keywordflow}{is} \textcolor{keyword}{False}: }
\DoxyCodeLine{257             \textcolor{comment}{\# special case: need a complete copy but there are already subarrays in this deivce }}
\DoxyCodeLine{258             \textcolor{comment}{\# writeback this subarrays and then copy complete data from owner }}
\DoxyCodeLine{259  }
\DoxyCodeLine{260             \textcolor{comment}{\# write back to owner }}
\DoxyCodeLine{261             operations.extend(self.\_write\_back\_to(self.owner, self.SHARED, on\_different\_device=\textcolor{keyword}{True})) }
\DoxyCodeLine{262  }
\DoxyCodeLine{263             \textcolor{comment}{\# evict previous subarries at device\_id }}
\DoxyCodeLine{264             operations.append(MemoryOperation.evict(device\_id)) }
\DoxyCodeLine{265              }
\DoxyCodeLine{266             \textcolor{comment}{\# copy from owner }}
\DoxyCodeLine{267             operations.append(MemoryOperation.load(device\_id, self.owner)) }
\DoxyCodeLine{268  }
\DoxyCodeLine{269             self.\_is\_complete[device\_id] = \textcolor{keyword}{True} }
\DoxyCodeLine{270             self.\_versions[device\_id] = self.\_versions[self.owner] }
\DoxyCodeLine{271             self.\_local\_states[self.owner] = self.SHARED  \textcolor{comment}{\# owner is updated, so it is in SHARED states }}
\DoxyCodeLine{272             self.\_local\_states[device\_id] = self.SHARED }
\DoxyCodeLine{273             self.\_cyparray\_state.set\_valid\_on\_device(self.owner, \textcolor{keyword}{True}) }
\DoxyCodeLine{274             self.\_cyparray\_state.set\_valid\_on\_device(device\_id, \textcolor{keyword}{True}) }
\DoxyCodeLine{275  }
\DoxyCodeLine{276             \textcolor{comment}{\# change owner }}
\DoxyCodeLine{277             \textcolor{keywordflow}{if} self.\_owner\_is\_latest(): }
\DoxyCodeLine{278                 \textcolor{keywordflow}{if} self.owner == CPU\_INDEX: }
\DoxyCodeLine{279                     self.owner = device\_id }
\DoxyCodeLine{280                 \textcolor{keywordflow}{elif} device\_id \% 2 == 0 \textcolor{keywordflow}{and} self.owner \% 2 != 0:  \textcolor{comment}{\# prefer device 0/2 over 1/3 }}
\DoxyCodeLine{281                     self.owner = device\_id }
\DoxyCodeLine{282             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{283                 self.owner = device\_id }
\DoxyCodeLine{284  }
\DoxyCodeLine{285             \textcolor{comment}{\# skip the rest code }}
\DoxyCodeLine{286             \textcolor{keywordflow}{return} operations }
\DoxyCodeLine{287         \textcolor{keywordflow}{else}:  \textcolor{comment}{\# move a complete copy and current device has no subarrays }}
\DoxyCodeLine{288             device\_local\_state = self.\_local\_states[device\_id] }
\DoxyCodeLine{289             self.\_is\_complete[device\_id] = \textcolor{keyword}{True}  \textcolor{comment}{\# this is a complete array }}
\DoxyCodeLine{290  }
\DoxyCodeLine{291  }
\DoxyCodeLine{292         \textcolor{keywordflow}{if} device\_id == self.owner: }
\DoxyCodeLine{293             \textcolor{keywordflow}{if} device\_local\_state == self.INVALID: \textcolor{comment}{\# update it to latest }}
\DoxyCodeLine{294                 operations.extend(self.\_write\_back\_to(device\_id, self.SHARED)) }
\DoxyCodeLine{295             \textcolor{keywordflow}{else}:   }
\DoxyCodeLine{296                 operations.append(MemoryOperation.noop()) }
\DoxyCodeLine{297         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{298             \textcolor{keywordflow}{if} device\_local\_state == self.INVALID: }
\DoxyCodeLine{299                 \textcolor{keywordflow}{if} self.\_is\_complete[device\_id]: }
\DoxyCodeLine{300                     operations.extend(self.\_write\_back\_to(device\_id, self.SHARED)) }
\DoxyCodeLine{301  }
\DoxyCodeLine{302                     \textcolor{comment}{\# change owner }}
\DoxyCodeLine{303                     \textcolor{keywordflow}{if} self.\_owner\_is\_latest(): }
\DoxyCodeLine{304                         \textcolor{keywordflow}{if} self.owner == CPU\_INDEX: }
\DoxyCodeLine{305                             self.owner = device\_id }
\DoxyCodeLine{306                         \textcolor{keywordflow}{elif} device\_id \% 2 == 0 \textcolor{keywordflow}{and} self.owner \% 2 != 0:  \textcolor{comment}{\# prefer device 0/2 over 1/3 }}
\DoxyCodeLine{307                             self.owner = device\_id }
\DoxyCodeLine{308                     \textcolor{keywordflow}{else}: }
\DoxyCodeLine{309                         self.owner = device\_id }
\DoxyCodeLine{310                     self.\_versions[device\_id] = self.\_latest\_version }
\DoxyCodeLine{311                 \textcolor{keywordflow}{else}:  \textcolor{comment}{\# since we assume all array are disjoint, so could load directly }}
\DoxyCodeLine{312                     operations.append(MemoryOperation.load(dst=device\_id, src=self.owner, is\_subarray=\textcolor{keyword}{True}))  }
\DoxyCodeLine{313  }
\DoxyCodeLine{314                     self.\_versions[device\_id][slices\_hash] = self.\_versions[self.owner] }
\DoxyCodeLine{315             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{316                 operations.append(MemoryOperation.noop()) }
\DoxyCodeLine{317  }
\DoxyCodeLine{318         \textcolor{comment}{\# update status }}
\DoxyCodeLine{319         \textcolor{keywordflow}{if} self.\_is\_complete[device\_id]: }
\DoxyCodeLine{320             \textcolor{keywordflow}{if} device\_local\_state == self.INVALID: }
\DoxyCodeLine{321                 self.\_local\_states[device\_id] = self.SHARED }
\DoxyCodeLine{322                 self.\_cyparray\_state.set\_valid\_on\_device(device\_id, \textcolor{keyword}{True}) }
\DoxyCodeLine{323         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{324             \textcolor{keywordflow}{if} device\_local\_state == self.INVALID: }
\DoxyCodeLine{325                 self.\_local\_states[device\_id][slices\_hash] = self.SHARED }
\DoxyCodeLine{326                 self.\_cyparray\_state.set\_valid\_on\_device(device\_id, \textcolor{keyword}{True}) }
\DoxyCodeLine{327  }
\DoxyCodeLine{328         \textcolor{keywordflow}{return} operations }
\DoxyCodeLine{329  }

\end{DoxyCode}


References parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+core.\+PArray.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+is\+\_\+complete, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+latest\+\_\+version, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+local\+\_\+states, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+owner\+\_\+is\+\_\+latest(), parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+versions, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+globals.\+Device\+Type.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+owner, and parla.\+common.\+parray.\+coherence.\+Coherence.\+SHARED.

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a56fa655ef59e928066e435969a5f24a6_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ad74ae936252243b5457f5239961bdbba}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ad74ae936252243b5457f5239961bdbba}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!reset@{reset}}
\index{reset@{reset}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily def parla.\+common.\+parray.\+coherence.\+Coherence.\+reset (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int}]{new\+\_\+owner }\end{DoxyParamCaption})}

\begin{DoxyVerb}Reset the coherence state to only `new_owner` has a valid modified copy
\end{DoxyVerb}
 

Definition at line 121 of file coherence.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{121     \textcolor{keyword}{def }reset(self, new\_owner: int): }
\DoxyCodeLine{122         \textcolor{stringliteral}{"{}"{}"{} }}
\DoxyCodeLine{123 \textcolor{stringliteral}{        Reset the coherence state to only `new\_owner` has a valid modified copy }}
\DoxyCodeLine{124 \textcolor{stringliteral}{        "{}"{}"{}} }
\DoxyCodeLine{125         \textcolor{keywordflow}{for} device\_id \textcolor{keywordflow}{in} self.\_local\_states.\mbox{\hyperlink{namespaceparla_1_1cython_1_1tasks_a83206470aa63f6e6fb8614d30dcbbe74}{keys}}(): }
\DoxyCodeLine{126             self.\_local\_states[device\_id] = self.INVALID }
\DoxyCodeLine{127             self.\_versions[device\_id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{128             self.\_is\_complete[device\_id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{129          }
\DoxyCodeLine{130         self.\_local\_states[new\_owner] = self.MODIFIED }
\DoxyCodeLine{131         self.owner = new\_owner }
\DoxyCodeLine{132         self.\_versions[new\_owner] = 0 }
\DoxyCodeLine{133         self.\_is\_complete[new\_owner] = \textcolor{keyword}{True} }
\DoxyCodeLine{134         self.\_latest\_version = 0 }
\DoxyCodeLine{135  }
\DoxyCodeLine{136         self.\_cyparray\_state.set\_valid\_on\_device(new\_owner, \textcolor{keyword}{True}) }
\DoxyCodeLine{137  }

\end{DoxyCode}


References parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+core.\+PArray.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+is\+\_\+complete, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+latest\+\_\+version, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+local\+\_\+states, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+versions, parla.\+common.\+globals.\+Device\+Type.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+INVALID, parla.\+cython.\+tasks.\+keys, parla.\+common.\+parray.\+coherence.\+Coherence.\+MODIFIED, and parla.\+common.\+parray.\+coherence.\+Coherence.\+owner.

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2095bb13a7452502292d7777d68a6828}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2095bb13a7452502292d7777d68a6828}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!write@{write}}
\index{write@{write}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{write()}{write()}}
{\footnotesize\ttfamily  List\mbox{[}\mbox{\hyperlink{classparla_1_1common_1_1parray_1_1coherence_1_1MemoryOperation}{Memory\+Operation}}\mbox{]} parla.\+common.\+parray.\+coherence.\+Coherence.\+write (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int}]{device\+\_\+id,  }\item[{int }]{slices\+\_\+hash = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb} Tell the protocol that this device write to the copy.

Args:
    device_id: id of this device
    slices_hash: hash code of the slices of the subarray to be manipulated
                 by default equals to None, which means the whole array is manipulated

Return:
    List[MemoryOperation], which tell how data will be manipulated, and order matter.
\end{DoxyVerb}
 

Definition at line 330 of file coherence.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{330     \textcolor{keyword}{def }write(self, device\_id: int, slices\_hash: int = \textcolor{keywordtype}{None}) -\/> List[MemoryOperation]: }
\DoxyCodeLine{331         \textcolor{stringliteral}{"{}"{}"{} Tell the protocol that this device write to the copy. }}
\DoxyCodeLine{332 \textcolor{stringliteral}{ }}
\DoxyCodeLine{333 \textcolor{stringliteral}{        Args: }}
\DoxyCodeLine{334 \textcolor{stringliteral}{            device\_id: id of this device }}
\DoxyCodeLine{335 \textcolor{stringliteral}{            slices\_hash: hash code of the slices of the subarray to be manipulated }}
\DoxyCodeLine{336 \textcolor{stringliteral}{                         by default equals to None, which means the whole array is manipulated }}
\DoxyCodeLine{337 \textcolor{stringliteral}{ }}
\DoxyCodeLine{338 \textcolor{stringliteral}{        Return: }}
\DoxyCodeLine{339 \textcolor{stringliteral}{            List[MemoryOperation], which tell how data will be manipulated, and order matter. }}
\DoxyCodeLine{340 \textcolor{stringliteral}{        "{}"{}"{}} }
\DoxyCodeLine{341         operations = [] }
\DoxyCodeLine{342  }
\DoxyCodeLine{343         \textcolor{keywordflow}{if} slices\_hash \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}: \textcolor{comment}{\# move a subarray }}
\DoxyCodeLine{344             \textcolor{keywordflow}{if} self.\_is\_complete[device\_id] \textcolor{keywordflow}{is} \textcolor{keyword}{True}:  \textcolor{comment}{\# use existing complete data at this device }}
\DoxyCodeLine{345                 device\_local\_state = self.\_local\_states[device\_id] }
\DoxyCodeLine{346             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{347                 \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(self.\_local\_states[device\_id], dict): }
\DoxyCodeLine{348                     self.\_versions[device\_id] = \{\} }
\DoxyCodeLine{349                     self.\_local\_states[device\_id] = \{\} }
\DoxyCodeLine{350                     device\_local\_state = self.INVALID }
\DoxyCodeLine{351                 \textcolor{keywordflow}{elif} slices\_hash \textcolor{keywordflow}{in} self.\_local\_states[device\_id]: }
\DoxyCodeLine{352                     device\_local\_state = self.\_local\_states[device\_id][slices\_hash] }
\DoxyCodeLine{353                 \textcolor{keywordflow}{else}: }
\DoxyCodeLine{354                     device\_local\_state = self.INVALID }
\DoxyCodeLine{355                 self.\_is\_complete[device\_id] = \textcolor{keyword}{False}  \textcolor{comment}{\# this is a subarray }}
\DoxyCodeLine{356         \textcolor{keywordflow}{elif} self.\_is\_complete[device\_id] \textcolor{keywordflow}{is} \textcolor{keyword}{False}: }
\DoxyCodeLine{357             \textcolor{comment}{\# special case: need a complete copy but there are already subarrays in this deivce }}
\DoxyCodeLine{358             \textcolor{comment}{\# writeback this subarrays and then copy complete data from owner }}
\DoxyCodeLine{359  }
\DoxyCodeLine{360             \textcolor{comment}{\# write back to owner  }}
\DoxyCodeLine{361             operations.extend(self.\_write\_back\_to(self.owner, self.MODIFIED,  }
\DoxyCodeLine{362                                 on\_different\_device=\textcolor{keyword}{True})) }
\DoxyCodeLine{363              }
\DoxyCodeLine{364             \textcolor{comment}{\# copy from owner }}
\DoxyCodeLine{365             operations.append(MemoryOperation.load(device\_id, self.owner)) }
\DoxyCodeLine{366  }
\DoxyCodeLine{367             self.\_is\_complete[device\_id] = \textcolor{keyword}{True} }
\DoxyCodeLine{368             self.\_versions[device\_id] = self.\_versions[self.owner] }
\DoxyCodeLine{369             self.\_local\_states[device\_id] = self.MODIFIED }
\DoxyCodeLine{370             self.\_local\_states[self.owner] = self.INVALID  \textcolor{comment}{\# owner is invalid too }}
\DoxyCodeLine{371             self.\_cyparray\_state.set\_valid\_on\_device(device\_id, \textcolor{keyword}{True}) }
\DoxyCodeLine{372             self.\_cyparray\_state.set\_valid\_on\_device(self.owner, \textcolor{keyword}{True}) }
\DoxyCodeLine{373  }
\DoxyCodeLine{374             \textcolor{comment}{\# change owner }}
\DoxyCodeLine{375             self.owner = device\_id }
\DoxyCodeLine{376  }
\DoxyCodeLine{377             \textcolor{comment}{\# skip the rest code }}
\DoxyCodeLine{378             \textcolor{keywordflow}{return} operations }
\DoxyCodeLine{379         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{380             device\_local\_state = self.\_local\_states[device\_id] }
\DoxyCodeLine{381             self.\_is\_complete[device\_id] = \textcolor{keyword}{True}  \textcolor{comment}{\# this is a complete array }}
\DoxyCodeLine{382  }
\DoxyCodeLine{383         \textcolor{keywordflow}{if} device\_id == self.owner: }
\DoxyCodeLine{384             \textcolor{keywordflow}{if} device\_local\_state != self.MODIFIED: }
\DoxyCodeLine{385                 operations.extend(self.\_write\_back\_to(device\_id, self.MODIFIED)) }
\DoxyCodeLine{386  }
\DoxyCodeLine{387                 self.\_latest\_version += 1 }
\DoxyCodeLine{388                 self.\_versions[device\_id] = self.\_latest\_version }
\DoxyCodeLine{389             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{390                 operations.append(MemoryOperation.noop()) }
\DoxyCodeLine{391         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{392             \textcolor{keywordflow}{if} device\_local\_state == self.INVALID: }
\DoxyCodeLine{393                 \textcolor{keywordflow}{if} self.\_is\_complete[device\_id]: }
\DoxyCodeLine{394                     operations.extend(self.\_write\_back\_to(device\_id, self.MODIFIED)) }
\DoxyCodeLine{395  }
\DoxyCodeLine{396                     self.\_latest\_version += 1 }
\DoxyCodeLine{397                     self.\_versions[device\_id] = self.\_latest\_version }
\DoxyCodeLine{398  }
\DoxyCodeLine{399                     \textcolor{comment}{\# change owner }}
\DoxyCodeLine{400                     self.owner = device\_id }
\DoxyCodeLine{401                 \textcolor{keywordflow}{else}:  \textcolor{comment}{\# since we assume all subarrays are disjoint, could load directly }}
\DoxyCodeLine{402                     operations.append(MemoryOperation.load(dst=device\_id, src=self.owner, is\_subarray=\textcolor{keyword}{True})) }
\DoxyCodeLine{403  }
\DoxyCodeLine{404                     self.\_versions[device\_id][slices\_hash] = self.\_versions[self.owner] + 1 }
\DoxyCodeLine{405                     \textcolor{keywordflow}{if} self.\_owner\_is\_latest(): }
\DoxyCodeLine{406                         self.\_latest\_version += 1 }
\DoxyCodeLine{407                     self.\_local\_states[self.owner] = self.INVALID  \textcolor{comment}{\# invalidate overlapping copy }}
\DoxyCodeLine{408                     self.\_cyparray\_state.set\_valid\_on\_device(self.owner, \textcolor{keyword}{False}) }
\DoxyCodeLine{409             \textcolor{keywordflow}{elif} device\_local\_state == self.SHARED: }
\DoxyCodeLine{410                 \textcolor{keywordflow}{if} self.\_is\_complete[device\_id]: }
\DoxyCodeLine{411                     self.\_latest\_version += 1 }
\DoxyCodeLine{412                     self.\_versions[device\_id] = self.\_latest\_version }
\DoxyCodeLine{413  }
\DoxyCodeLine{414                     \textcolor{comment}{\# change owner }}
\DoxyCodeLine{415                     self.owner = device\_id }
\DoxyCodeLine{416  }
\DoxyCodeLine{417                     \textcolor{comment}{\# evict others }}
\DoxyCodeLine{418                     operations.extend(self.\_write\_back\_to(device\_id, self.MODIFIED)) }
\DoxyCodeLine{419                 \textcolor{keywordflow}{else}: }
\DoxyCodeLine{420                     self.\_latest\_version += 1 }
\DoxyCodeLine{421                     self.\_versions[device\_id][slices\_hash] = self.\_latest\_version }
\DoxyCodeLine{422  }
\DoxyCodeLine{423                     \textcolor{comment}{\# invalidate other complete copies }}
\DoxyCodeLine{424                     \textcolor{keywordflow}{for} id, state \textcolor{keywordflow}{in} self.\_local\_states.items(): }
\DoxyCodeLine{425                         \textcolor{comment}{\# since we assume all subarrays are disjoint, so don't need to evict other subarrays }}
\DoxyCodeLine{426                         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(state, dict): }
\DoxyCodeLine{427                             \textcolor{keywordflow}{if} id != device\_id: }
\DoxyCodeLine{428                                 self.\_local\_states[id] = self.INVALID }
\DoxyCodeLine{429                                 self.\_cyparray\_state.set\_valid\_on\_device(id, \textcolor{keyword}{False}) }
\DoxyCodeLine{430  }
\DoxyCodeLine{431                                 \textcolor{keywordflow}{if} id != self.owner:  \textcolor{comment}{\# owner's buffer will be kept (so won't lost the last complete copy) }}
\DoxyCodeLine{432                                     self.\_versions[id] = -\/1 }
\DoxyCodeLine{433                                     self.\_is\_complete[id] = \textcolor{keywordtype}{None} }
\DoxyCodeLine{434                                     operations.append(MemoryOperation.evict(id)) }
\DoxyCodeLine{435                     \textcolor{keywordflow}{if} len(operations) == 0: }
\DoxyCodeLine{436                         operations.append(MemoryOperation.noop()) }
\DoxyCodeLine{437             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{438                 operations.append(MemoryOperation.noop()) }
\DoxyCodeLine{439  }
\DoxyCodeLine{440         \textcolor{comment}{\# update status }}
\DoxyCodeLine{441         \textcolor{keywordflow}{if} self.\_is\_complete[device\_id]: }
\DoxyCodeLine{442             \textcolor{keywordflow}{if} device\_local\_state != self.MODIFIED: }
\DoxyCodeLine{443                 self.\_local\_states[device\_id] = self.MODIFIED }
\DoxyCodeLine{444                 self.\_cyparray\_state.set\_valid\_on\_device(device\_id, \textcolor{keyword}{True}) }
\DoxyCodeLine{445         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{446             \textcolor{keywordflow}{if} device\_local\_state != self.MODIFIED: }
\DoxyCodeLine{447                 self.\_local\_states[device\_id][slices\_hash] = self.MODIFIED }
\DoxyCodeLine{448                 self.\_cyparray\_state.set\_valid\_on\_device(device\_id, \textcolor{keyword}{True}) }
\DoxyCodeLine{449         \textcolor{keywordflow}{return} operations }
\DoxyCodeLine{450  }

\end{DoxyCode}


References parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+core.\+PArray.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+\_\+cyparray\+\_\+state, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+is\+\_\+complete, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+latest\+\_\+version, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+local\+\_\+states, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+owner\+\_\+is\+\_\+latest(), parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+versions, parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+globals.\+Device\+Type.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+INVALID, parla.\+common.\+parray.\+coherence.\+Coherence.\+MODIFIED, parla.\+common.\+parray.\+coherence.\+Coherence.\+owner, and parla.\+common.\+parray.\+coherence.\+Coherence.\+SHARED.

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a2095bb13a7452502292d7777d68a6828_cgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a5eac154e32a3306e30ced424ce5662bb}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a5eac154e32a3306e30ced424ce5662bb}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_cyparray\_state@{\_cyparray\_state}}
\index{\_cyparray\_state@{\_cyparray\_state}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_cyparray\_state}{\_cyparray\_state}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+cyparray\+\_\+state\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 118 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+clear(), parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+copy\+\_\+data\+\_\+between\+\_\+device(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+set(), parla.\+common.\+parray.\+memory.\+Multi\+Device\+Buffer.\+set\+\_\+complete\+\_\+array(), parla.\+common.\+parray.\+core.\+PArray.\+update(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a58492eb01469b98a98756fc737d59b51}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a58492eb01469b98a98756fc737d59b51}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_global\_state@{\_global\_state}}
\index{\_global\_state@{\_global\_state}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_global\_state}{\_global\_state}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+global\+\_\+state\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 502 of file coherence.\+py.

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_afc7961eea4c23bb6addd772c4d1b1774}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_afc7961eea4c23bb6addd772c4d1b1774}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_is\_complete@{\_is\_complete}}
\index{\_is\_complete@{\_is\_complete}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_is\_complete}{\_is\_complete}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+is\+\_\+complete\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 106 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ab805678c6c7fae95deb305f6df7f45f2}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ab805678c6c7fae95deb305f6df7f45f2}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_latest\_version@{\_latest\_version}}
\index{\_latest\_version@{\_latest\_version}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_latest\_version}{\_latest\_version}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+latest\+\_\+version\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 113 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+owner\+\_\+is\+\_\+latest(), parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a76699d6bbc8fcc5c681eabb8900d9596}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a76699d6bbc8fcc5c681eabb8900d9596}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_local\_states@{\_local\_states}}
\index{\_local\_states@{\_local\_states}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_local\_states}{\_local\_states}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+local\+\_\+states\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 97 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a142ce1b3c9cd44ed5673ac6807b6552a}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a142ce1b3c9cd44ed5673ac6807b6552a}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_lock@{\_lock}}
\index{\_lock@{\_lock}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_lock}{\_lock}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+lock\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 116 of file coherence.\+py.

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a0e6c612937b2e7aaaa0644be15443118}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a0e6c612937b2e7aaaa0644be15443118}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!\_versions@{\_versions}}
\index{\_versions@{\_versions}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{\_versions}{\_versions}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+versions\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 102 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+owner\+\_\+is\+\_\+latest(), parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a790c9623a24f7ad2b8a81945751959d8}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a790c9623a24f7ad2b8a81945751959d8}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!INVALID@{INVALID}}
\index{INVALID@{INVALID}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{INVALID}{INVALID}}
{\footnotesize\ttfamily int parla.\+common.\+parray.\+coherence.\+Coherence.\+INVALID = 0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 77 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a66d670594be720ef3f31d01fb3a5e780}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a66d670594be720ef3f31d01fb3a5e780}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!MODIFIED@{MODIFIED}}
\index{MODIFIED@{MODIFIED}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{MODIFIED}{MODIFIED}}
{\footnotesize\ttfamily int parla.\+common.\+parray.\+coherence.\+Coherence.\+MODIFIED = 2\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 79 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a64860ee1101484eda6d85f88fe54186b}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_a64860ee1101484eda6d85f88fe54186b}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!owner@{owner}}
\index{owner@{owner}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{owner}{owner}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+coherence.\+Coherence.\+owner}



Definition at line 110 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+owner\+\_\+is\+\_\+latest(), parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), parla.\+common.\+parray.\+coherence.\+Coherence.\+reset(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().

\mbox{\Hypertarget{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ab4bf22d2fb6e3497a05f31b046288d26}\label{classparla_1_1common_1_1parray_1_1coherence_1_1Coherence_ab4bf22d2fb6e3497a05f31b046288d26}} 
\index{parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}!SHARED@{SHARED}}
\index{SHARED@{SHARED}!parla.common.parray.coherence.Coherence@{parla.common.parray.coherence.Coherence}}
\doxysubsubsection{\texorpdfstring{SHARED}{SHARED}}
{\footnotesize\ttfamily int parla.\+common.\+parray.\+coherence.\+Coherence.\+SHARED = 1\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 78 of file coherence.\+py.



Referenced by parla.\+common.\+parray.\+coherence.\+Coherence.\+\_\+write\+\_\+back\+\_\+to(), parla.\+common.\+parray.\+coherence.\+Coherence.\+evict(), parla.\+common.\+parray.\+coherence.\+Coherence.\+read(), and parla.\+common.\+parray.\+coherence.\+Coherence.\+write().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/python/parla/common/parray/\mbox{\hyperlink{coherence_8py}{coherence.\+py}}\end{DoxyCompactItemize}
