\hypertarget{namespaceparla_1_1common_1_1parray_1_1from__data}{}\doxysection{parla.\+common.\+parray.\+from\+\_\+data Namespace Reference}
\label{namespaceparla_1_1common_1_1parray_1_1from__data}\index{parla.common.parray.from\_data@{parla.common.parray.from\_data}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a567d00461d0389254b7eebf7e1ddf76a}{array}} (object, dtype=None, copy=True, order=\textquotesingle{}K\textquotesingle{}, subok=False, ndmin=0, like=None, on\+\_\+gpu=False, str name=\char`\"{}NA\char`\"{})
\item 
def \mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a8632d3fcf2de6f3858522c7730a85fc2}{asarray}} (a, dtype=None, order=None, like=None, on\+\_\+gpu=False, str name=\char`\"{}NA\char`\"{})
\item 
def \mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a90739817f271f32701c3dd78d75c3c30}{asarray\+\_\+batch}} ($\ast$args)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_af80dd4feec40dcb3e88dd8f1db499a2d}{cupy}} = numpy
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespaceparla_1_1common_1_1parray_1_1from__data_a567d00461d0389254b7eebf7e1ddf76a}\label{namespaceparla_1_1common_1_1parray_1_1from__data_a567d00461d0389254b7eebf7e1ddf76a}} 
\index{parla.common.parray.from\_data@{parla.common.parray.from\_data}!array@{array}}
\index{array@{array}!parla.common.parray.from\_data@{parla.common.parray.from\_data}}
\doxysubsubsection{\texorpdfstring{array()}{array()}}
{\footnotesize\ttfamily def parla.\+common.\+parray.\+from\+\_\+data.\+array (\begin{DoxyParamCaption}\item[{}]{object,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{copy = {\ttfamily True},  }\item[{}]{order = {\ttfamily \textquotesingle{}K\textquotesingle{}},  }\item[{}]{subok = {\ttfamily False},  }\item[{}]{ndmin = {\ttfamily 0},  }\item[{}]{like = {\ttfamily None},  }\item[{}]{on\+\_\+gpu = {\ttfamily False},  }\item[{str }]{name = {\ttfamily \char`\"{}NA\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Create a Parla array on the specific device (CPU by default).

Args:
    object: :class:`cupy.ndarray` or :class:`numpy.array` object
        or any other object that can be passed to `numpy.array`.

    dtype: Data type specifier.
    copy (bool): If ``False``, this function returns ``obj`` if possible.
        Otherwise this function always returns a new array.
    order ({'C', 'F', 'A', 'K'}): Row-major (C-style) or column-major
        (Fortran-style) order.
        When ``order`` is ``'A'``, it uses ``'F'`` if ``a`` is column-major
        and uses ``'C'`` otherwise.
        And when ``order`` is ``'K'``, it keeps strides as closely as
        possible.
        If ``obj`` is `numpy.ndarray`, the function returns ``'C'``
        or ``'F'`` order array.
        Ignored for cupy(GPU) array.
    subok (bool): If ``True``, then sub-classes will be passed-through,
        otherwise the returned array will be forced to be a base-class
        array (default).
    ndmin (int): Minimum number of dimensions. Ones are inserted to the
        head of the shape if needed.
    like (array_like): Reference object to allow the creation of arrays 
        which are not NumPy arrays. If an array-like passed in as like 
        supports the __array_function__ protocol, the result will be defined by it. 
        In this case, it ensures the creation of an array object compatible with that passed in via this argument.
        New in Numpy version 1.20.0.
        Ignored for cupy(GPU) array.
    on_gpu (bool):
        if ``True``, the new array will be allocated on GPU
        otherwise the new array will be allocated on CPU

Returns:
    parray.PArray: An array on the current device.
\end{DoxyVerb}
 

Definition at line 10 of file from\+\_\+data.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{10 \textcolor{keyword}{def }\mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a567d00461d0389254b7eebf7e1ddf76a}{array}}(object, dtype=None, copy=True, order='K', subok=False, ndmin=0, like=None, on\_gpu=False, name: str = \textcolor{stringliteral}{"{}NA"{}}): }
\DoxyCodeLine{11     \textcolor{stringliteral}{"{}"{}"{} }}
\DoxyCodeLine{12 \textcolor{stringliteral}{    Create a Parla array on the specific device (CPU by default). }}
\DoxyCodeLine{13 \textcolor{stringliteral}{ }}
\DoxyCodeLine{14 \textcolor{stringliteral}{    Args: }}
\DoxyCodeLine{15 \textcolor{stringliteral}{        object: :class:`cupy.ndarray` or :class:`numpy.array` object }}
\DoxyCodeLine{16 \textcolor{stringliteral}{            or any other object that can be passed to `numpy.array`. }}
\DoxyCodeLine{17 \textcolor{stringliteral}{ }}
\DoxyCodeLine{18 \textcolor{stringliteral}{        dtype: Data type specifier. }}
\DoxyCodeLine{19 \textcolor{stringliteral}{        copy (bool): If ``False``, this function returns ``obj`` if possible. }}
\DoxyCodeLine{20 \textcolor{stringliteral}{            Otherwise this function always returns a new array. }}
\DoxyCodeLine{21 \textcolor{stringliteral}{        order (\{'C', 'F', 'A', 'K'\}): Row-\/major (C-\/style) or column-\/major }}
\DoxyCodeLine{22 \textcolor{stringliteral}{            (Fortran-\/style) order. }}
\DoxyCodeLine{23 \textcolor{stringliteral}{            When ``order`` is ``'A'``, it uses ``'F'`` if ``a`` is column-\/major }}
\DoxyCodeLine{24 \textcolor{stringliteral}{            and uses ``'C'`` otherwise. }}
\DoxyCodeLine{25 \textcolor{stringliteral}{            And when ``order`` is ``'K'``, it keeps strides as closely as }}
\DoxyCodeLine{26 \textcolor{stringliteral}{            possible. }}
\DoxyCodeLine{27 \textcolor{stringliteral}{            If ``obj`` is `numpy.ndarray`, the function returns ``'C'`` }}
\DoxyCodeLine{28 \textcolor{stringliteral}{            or ``'F'`` order array. }}
\DoxyCodeLine{29 \textcolor{stringliteral}{            Ignored for cupy(GPU) array. }}
\DoxyCodeLine{30 \textcolor{stringliteral}{        subok (bool): If ``True``, then sub-\/classes will be passed-\/through, }}
\DoxyCodeLine{31 \textcolor{stringliteral}{            otherwise the returned array will be forced to be a base-\/class }}
\DoxyCodeLine{32 \textcolor{stringliteral}{            array (default). }}
\DoxyCodeLine{33 \textcolor{stringliteral}{        ndmin (int): Minimum number of dimensions. Ones are inserted to the }}
\DoxyCodeLine{34 \textcolor{stringliteral}{            head of the shape if needed. }}
\DoxyCodeLine{35 \textcolor{stringliteral}{        like (array\_like): Reference object to allow the creation of arrays  }}
\DoxyCodeLine{36 \textcolor{stringliteral}{            which are not NumPy arrays. If an array-\/like passed in as like  }}
\DoxyCodeLine{37 \textcolor{stringliteral}{            supports the \_\_array\_function\_\_ protocol, the result will be defined by it.  }}
\DoxyCodeLine{38 \textcolor{stringliteral}{            In this case, it ensures the creation of an array object compatible with that passed in via this argument. }}
\DoxyCodeLine{39 \textcolor{stringliteral}{            New in Numpy version 1.20.0. }}
\DoxyCodeLine{40 \textcolor{stringliteral}{            Ignored for cupy(GPU) array. }}
\DoxyCodeLine{41 \textcolor{stringliteral}{        on\_gpu (bool): }}
\DoxyCodeLine{42 \textcolor{stringliteral}{            if ``True``, the new array will be allocated on GPU }}
\DoxyCodeLine{43 \textcolor{stringliteral}{            otherwise the new array will be allocated on CPU }}
\DoxyCodeLine{44 \textcolor{stringliteral}{ }}
\DoxyCodeLine{45 \textcolor{stringliteral}{    Returns: }}
\DoxyCodeLine{46 \textcolor{stringliteral}{        parray.PArray: An array on the current device. }}
\DoxyCodeLine{47 \textcolor{stringliteral}{    "{}"{}"{}} }
\DoxyCodeLine{48     \textcolor{comment}{\# if the input is already an ndarray }}
\DoxyCodeLine{49     \textcolor{keywordflow}{if} isinstance(object, (numpy.ndarray, cupy.ndarray)): }
\DoxyCodeLine{50         \textcolor{keywordflow}{if} copy: }
\DoxyCodeLine{51             parray = \mbox{\hyperlink{namespaceparla_1_1utility_1_1execute_a77cf484a209c81a25d537fd8ba9601a2}{PArray}}(object.copy(), name=name) }
\DoxyCodeLine{52         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{53             parray = \mbox{\hyperlink{namespaceparla_1_1utility_1_1execute_a77cf484a209c81a25d537fd8ba9601a2}{PArray}}(object, name=name) }
\DoxyCodeLine{54     \textcolor{keywordflow}{elif} isinstance(object, PArray):  \textcolor{comment}{\# Already an PArray }}
\DoxyCodeLine{55         \textcolor{keywordflow}{if} copy: }
\DoxyCodeLine{56             parray = \mbox{\hyperlink{namespaceparla_1_1utility_1_1execute_a77cf484a209c81a25d537fd8ba9601a2}{PArray}}(object.array.copy(), name=name) }
\DoxyCodeLine{57         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{58             parray = \mbox{\hyperlink{namespaceparla_1_1utility_1_1execute_a77cf484a209c81a25d537fd8ba9601a2}{PArray}}(object.array, name=name) }
\DoxyCodeLine{59     \textcolor{keywordflow}{else}:  \textcolor{comment}{\# create one if it is not an ndarray }}
\DoxyCodeLine{60         \textcolor{keywordflow}{if} on\_gpu: }
\DoxyCodeLine{61             parray = \mbox{\hyperlink{namespaceparla_1_1utility_1_1execute_a77cf484a209c81a25d537fd8ba9601a2}{PArray}}(cupy.array(object, dtype=dtype, }
\DoxyCodeLine{62                             copy=copy, order=order, subok=subok, ndmin=ndmin), name=name) }
\DoxyCodeLine{63         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{64             \textcolor{keywordflow}{if} like: }
\DoxyCodeLine{65                 parray = \mbox{\hyperlink{namespaceparla_1_1utility_1_1execute_a77cf484a209c81a25d537fd8ba9601a2}{PArray}}(numpy.array( }
\DoxyCodeLine{66                     object, dtype=dtype, copy=copy, order=order, subok=subok, ndmin=ndmin, like=like), name=name) }
\DoxyCodeLine{67             \textcolor{keywordflow}{else}: }
\DoxyCodeLine{68                 parray = \mbox{\hyperlink{namespaceparla_1_1utility_1_1execute_a77cf484a209c81a25d537fd8ba9601a2}{PArray}}(numpy.array( }
\DoxyCodeLine{69                     object, dtype=dtype, copy=copy, order=order, subok=subok, ndmin=ndmin), name=name) }
\DoxyCodeLine{70     \textcolor{keywordflow}{return} parray }
\DoxyCodeLine{71  }
\DoxyCodeLine{72  }

\end{DoxyCode}


Referenced by parla.\+common.\+parray.\+from\+\_\+data.\+asarray().

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespaceparla_1_1common_1_1parray_1_1from__data_a567d00461d0389254b7eebf7e1ddf76a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespaceparla_1_1common_1_1parray_1_1from__data_a8632d3fcf2de6f3858522c7730a85fc2}\label{namespaceparla_1_1common_1_1parray_1_1from__data_a8632d3fcf2de6f3858522c7730a85fc2}} 
\index{parla.common.parray.from\_data@{parla.common.parray.from\_data}!asarray@{asarray}}
\index{asarray@{asarray}!parla.common.parray.from\_data@{parla.common.parray.from\_data}}
\doxysubsubsection{\texorpdfstring{asarray()}{asarray()}}
{\footnotesize\ttfamily def parla.\+common.\+parray.\+from\+\_\+data.\+asarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{like = {\ttfamily None},  }\item[{}]{on\+\_\+gpu = {\ttfamily False},  }\item[{str }]{name = {\ttfamily \char`\"{}NA\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts an object to Parla array.

This is equivalent to :class:``array(a, dtype, on_gpu, copy=False)``.

Args:
    a: The source object.
    dtype: Data type specifier. It is inferred from the input by default.
    order ({'C', 'F', 'A', 'K'}): Row-major (C-style) or column-major
        (Fortran-style) order.
        When ``order`` is ``'A'``, it uses ``'F'`` if ``a`` is column-major
        and uses ``'C'`` otherwise.
        And when ``order`` is ``'K'``, it keeps strides as closely as
        possible.
        If ``obj`` is `numpy.ndarray`, the function returns ``'C'``
        or ``'F'`` order array.
    like (array_like): Reference object to allow the creation of arrays 
        which are not NumPy arrays. If an array-like passed in as like 
        supports the __array_function__ protocol, the result will be defined by it. 
        In this case, it ensures the creation of an array object compatible with that passed in via this argument.
        New in Numpy version 1.20.0.
        Ignored for cupy(GPU) array.
    on_gpu (bool):
        if ``True``, the new array will be allocated on GPU
        otherwise the new array will be allocated on CPU

Returns:
    parray.PArray: An array on the current device. If ``a`` is already on
    the device, no copy is performed.

.. note::
   If ``a`` is an :class:`numpy.ndarray` instance that contains big-endian data,
   this function automatically swaps its byte order to little-endian,
   which is the NVIDIA and AMD GPU architecture's native use.

.. seealso:: :func:`numpy.asarray`
\end{DoxyVerb}
 

Definition at line 73 of file from\+\_\+data.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{73 \textcolor{keyword}{def }\mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a8632d3fcf2de6f3858522c7730a85fc2}{asarray}}(a, dtype=None, order=None, like=None, on\_gpu=False, name: str = \textcolor{stringliteral}{"{}NA"{}}): }
\DoxyCodeLine{74     \textcolor{stringliteral}{"{}"{}"{}Converts an object to Parla array. }}
\DoxyCodeLine{75 \textcolor{stringliteral}{ }}
\DoxyCodeLine{76 \textcolor{stringliteral}{    This is equivalent to :class:``array(a, dtype, on\_gpu, copy=False)``. }}
\DoxyCodeLine{77 \textcolor{stringliteral}{ }}
\DoxyCodeLine{78 \textcolor{stringliteral}{    Args: }}
\DoxyCodeLine{79 \textcolor{stringliteral}{        a: The source object. }}
\DoxyCodeLine{80 \textcolor{stringliteral}{        dtype: Data type specifier. It is inferred from the input by default. }}
\DoxyCodeLine{81 \textcolor{stringliteral}{        order (\{'C', 'F', 'A', 'K'\}): Row-\/major (C-\/style) or column-\/major }}
\DoxyCodeLine{82 \textcolor{stringliteral}{            (Fortran-\/style) order. }}
\DoxyCodeLine{83 \textcolor{stringliteral}{            When ``order`` is ``'A'``, it uses ``'F'`` if ``a`` is column-\/major }}
\DoxyCodeLine{84 \textcolor{stringliteral}{            and uses ``'C'`` otherwise. }}
\DoxyCodeLine{85 \textcolor{stringliteral}{            And when ``order`` is ``'K'``, it keeps strides as closely as }}
\DoxyCodeLine{86 \textcolor{stringliteral}{            possible. }}
\DoxyCodeLine{87 \textcolor{stringliteral}{            If ``obj`` is `numpy.ndarray`, the function returns ``'C'`` }}
\DoxyCodeLine{88 \textcolor{stringliteral}{            or ``'F'`` order array. }}
\DoxyCodeLine{89 \textcolor{stringliteral}{        like (array\_like): Reference object to allow the creation of arrays  }}
\DoxyCodeLine{90 \textcolor{stringliteral}{            which are not NumPy arrays. If an array-\/like passed in as like  }}
\DoxyCodeLine{91 \textcolor{stringliteral}{            supports the \_\_array\_function\_\_ protocol, the result will be defined by it.  }}
\DoxyCodeLine{92 \textcolor{stringliteral}{            In this case, it ensures the creation of an array object compatible with that passed in via this argument. }}
\DoxyCodeLine{93 \textcolor{stringliteral}{            New in Numpy version 1.20.0. }}
\DoxyCodeLine{94 \textcolor{stringliteral}{            Ignored for cupy(GPU) array. }}
\DoxyCodeLine{95 \textcolor{stringliteral}{        on\_gpu (bool): }}
\DoxyCodeLine{96 \textcolor{stringliteral}{            if ``True``, the new array will be allocated on GPU }}
\DoxyCodeLine{97 \textcolor{stringliteral}{            otherwise the new array will be allocated on CPU }}
\DoxyCodeLine{98 \textcolor{stringliteral}{ }}
\DoxyCodeLine{99 \textcolor{stringliteral}{    Returns: }}
\DoxyCodeLine{100 \textcolor{stringliteral}{        parray.PArray: An array on the current device. If ``a`` is already on }}
\DoxyCodeLine{101 \textcolor{stringliteral}{        the device, no copy is performed. }}
\DoxyCodeLine{102 \textcolor{stringliteral}{ }}
\DoxyCodeLine{103 \textcolor{stringliteral}{    .. note:: }}
\DoxyCodeLine{104 \textcolor{stringliteral}{       If ``a`` is an :class:`numpy.ndarray` instance that contains big-\/endian data, }}
\DoxyCodeLine{105 \textcolor{stringliteral}{       this function automatically swaps its byte order to little-\/endian, }}
\DoxyCodeLine{106 \textcolor{stringliteral}{       which is the NVIDIA and AMD GPU architecture's native use. }}
\DoxyCodeLine{107 \textcolor{stringliteral}{ }}
\DoxyCodeLine{108 \textcolor{stringliteral}{    .. seealso:: :func:`numpy.asarray` }}
\DoxyCodeLine{109 \textcolor{stringliteral}{    "{}"{}"{}} }
\DoxyCodeLine{110     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a567d00461d0389254b7eebf7e1ddf76a}{array}}(a, dtype=dtype, copy=\textcolor{keyword}{False}, order=order, like=like, on\_gpu=on\_gpu, name=name) }
\DoxyCodeLine{111  }
\DoxyCodeLine{112  }

\end{DoxyCode}


References parla.\+common.\+parray.\+from\+\_\+data.\+array().



Referenced by parla.\+common.\+parray.\+from\+\_\+data.\+asarray\+\_\+batch(), and parla.\+utility.\+execute.\+make\+\_\+parrays().

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespaceparla_1_1common_1_1parray_1_1from__data_a8632d3fcf2de6f3858522c7730a85fc2_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespaceparla_1_1common_1_1parray_1_1from__data_a8632d3fcf2de6f3858522c7730a85fc2_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespaceparla_1_1common_1_1parray_1_1from__data_a90739817f271f32701c3dd78d75c3c30}\label{namespaceparla_1_1common_1_1parray_1_1from__data_a90739817f271f32701c3dd78d75c3c30}} 
\index{parla.common.parray.from\_data@{parla.common.parray.from\_data}!asarray\_batch@{asarray\_batch}}
\index{asarray\_batch@{asarray\_batch}!parla.common.parray.from\_data@{parla.common.parray.from\_data}}
\doxysubsubsection{\texorpdfstring{asarray\_batch()}{asarray\_batch()}}
{\footnotesize\ttfamily def parla.\+common.\+parray.\+from\+\_\+data.\+asarray\+\_\+batch (\begin{DoxyParamCaption}\item[{$\ast$}]{args }\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts numpy/cupy ndarray to Parla array without creating additional copy.

Args:
    ```ndarray(s)```, or ```ndarray(s)``` in ```dict/list/tuple/set``` (could be nested).
    Its structure will be kept.

Return:
    the same number of Parla array that matches the inputs.

Example:
    a = numpy.array([1,2])
    b = [cupy.array([3,4]), cupy.array([3,4])]

    a, b = asarray_batch(a, b) # a and b are now parla array
\end{DoxyVerb}
 

Definition at line 113 of file from\+\_\+data.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{113 \textcolor{keyword}{def }\mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a90739817f271f32701c3dd78d75c3c30}{asarray\_batch}}(*args): }
\DoxyCodeLine{114     \textcolor{stringliteral}{"{}"{}"{}Converts numpy/cupy ndarray to Parla array without creating additional copy. }}
\DoxyCodeLine{115 \textcolor{stringliteral}{ }}
\DoxyCodeLine{116 \textcolor{stringliteral}{    Args: }}
\DoxyCodeLine{117 \textcolor{stringliteral}{        ```ndarray(s)```, or ```ndarray(s)``` in ```dict/list/tuple/set``` (could be nested). }}
\DoxyCodeLine{118 \textcolor{stringliteral}{        Its structure will be kept. }}
\DoxyCodeLine{119 \textcolor{stringliteral}{ }}
\DoxyCodeLine{120 \textcolor{stringliteral}{    Return: }}
\DoxyCodeLine{121 \textcolor{stringliteral}{        the same number of Parla array that matches the inputs. }}
\DoxyCodeLine{122 \textcolor{stringliteral}{ }}
\DoxyCodeLine{123 \textcolor{stringliteral}{    Example: }}
\DoxyCodeLine{124 \textcolor{stringliteral}{        a = numpy.array([1,2]) }}
\DoxyCodeLine{125 \textcolor{stringliteral}{        b = [cupy.array([3,4]), cupy.array([3,4])] }}
\DoxyCodeLine{126 \textcolor{stringliteral}{ }}
\DoxyCodeLine{127 \textcolor{stringliteral}{        a, b = asarray\_batch(a, b) \# a and b are now parla array }}
\DoxyCodeLine{128 \textcolor{stringliteral}{    "{}"{}"{}} }
\DoxyCodeLine{129     \textcolor{keyword}{def }get\_parray(object):  \textcolor{comment}{\# recursively process Sequence or Dictionary }}
\DoxyCodeLine{130         \textcolor{keywordflow}{if} isinstance(object, (numpy.ndarray, cupy.ndarray)): }
\DoxyCodeLine{131             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespaceparla_1_1common_1_1parray_1_1from__data_a8632d3fcf2de6f3858522c7730a85fc2}{asarray}}(object) }
\DoxyCodeLine{132         \textcolor{keywordflow}{elif} isinstance(object, PArray): }
\DoxyCodeLine{133             \textcolor{keywordflow}{return} object }
\DoxyCodeLine{134         \textcolor{keywordflow}{elif} isinstance(object, dict): }
\DoxyCodeLine{135             accumulator = \{\} }
\DoxyCodeLine{136             \textcolor{keywordflow}{for} key, value \textcolor{keywordflow}{in} object.items(): }
\DoxyCodeLine{137                 accumulator[key] = get\_parray(value) }
\DoxyCodeLine{138             \textcolor{keywordflow}{return} accumulator }
\DoxyCodeLine{139         \textcolor{keywordflow}{elif} isinstance(object, (list, tuple, set)): }
\DoxyCodeLine{140             accumulator = [] }
\DoxyCodeLine{141             \textcolor{keywordflow}{for} item \textcolor{keywordflow}{in} object: }
\DoxyCodeLine{142                 accumulator.append(get\_parray(item)) }
\DoxyCodeLine{143             \textcolor{keywordflow}{return} type(object)(accumulator) }
\DoxyCodeLine{144         \textcolor{keywordflow}{else}: }
\DoxyCodeLine{145             \textcolor{keywordflow}{raise} TypeError(f\textcolor{stringliteral}{"{}Unsupported Type: \{type(object)\}"{}}) }
\DoxyCodeLine{146  }
\DoxyCodeLine{147     parla\_arrays = [] }
\DoxyCodeLine{148     \textcolor{keywordflow}{for} arg \textcolor{keywordflow}{in} args: }
\DoxyCodeLine{149         parla\_arrays.append(get\_parray(arg)) }
\DoxyCodeLine{150  }
\DoxyCodeLine{151     \textcolor{keywordflow}{if} len(parla\_arrays) == 1: }
\DoxyCodeLine{152         \textcolor{keywordflow}{return} parla\_arrays[0] }
\DoxyCodeLine{153     \textcolor{keywordflow}{else}: }
\DoxyCodeLine{154         \textcolor{keywordflow}{return} parla\_arrays  \textcolor{comment}{\# recommend user to unpack this }}

\end{DoxyCode}


References parla.\+common.\+parray.\+from\+\_\+data.\+asarray().

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespaceparla_1_1common_1_1parray_1_1from__data_a90739817f271f32701c3dd78d75c3c30_cgraph}
\end{center}
\end{figure}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespaceparla_1_1common_1_1parray_1_1from__data_af80dd4feec40dcb3e88dd8f1db499a2d}\label{namespaceparla_1_1common_1_1parray_1_1from__data_af80dd4feec40dcb3e88dd8f1db499a2d}} 
\index{parla.common.parray.from\_data@{parla.common.parray.from\_data}!cupy@{cupy}}
\index{cupy@{cupy}!parla.common.parray.from\_data@{parla.common.parray.from\_data}}
\doxysubsubsection{\texorpdfstring{cupy}{cupy}}
{\footnotesize\ttfamily parla.\+common.\+parray.\+from\+\_\+data.\+cupy = numpy}



Definition at line 7 of file from\+\_\+data.\+py.

