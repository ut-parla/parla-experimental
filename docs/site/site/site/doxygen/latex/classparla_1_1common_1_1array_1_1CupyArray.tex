\hypertarget{classparla_1_1common_1_1array_1_1CupyArray}{}\doxysection{parla.\+common.\+array.\+Cupy\+Array Class Reference}
\label{classparla_1_1common_1_1array_1_1CupyArray}\index{parla.common.array.CupyArray@{parla.common.array.CupyArray}}


Inheritance diagram for parla.\+common.\+array.\+Cupy\+Array\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=248pt]{classparla_1_1common_1_1array_1_1CupyArray__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for parla.\+common.\+array.\+Cupy\+Array\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=248pt]{classparla_1_1common_1_1array_1_1CupyArray__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classparla_1_1common_1_1array_1_1CupyArray_a215aed18e367dc2bd33c2d7acee29d2b}{can\+\_\+assign\+\_\+from}} (self, src, dst)
\item 
def \mbox{\hyperlink{classparla_1_1common_1_1array_1_1CupyArray_a05613760234518c4446c79c14dfa6fd9}{get\+\_\+array\+\_\+module}} (self, a)
\item 
def \mbox{\hyperlink{classparla_1_1common_1_1array_1_1CupyArray_a1edea9230a248ec1b62fbec90c0bba92}{copy\+\_\+from}} (self, src, int target\+\_\+device\+\_\+id)
\item 
def \mbox{\hyperlink{classparla_1_1common_1_1array_1_1CupyArray_a85d9d51515a3ea45a322b92dbc22238f}{copy\+\_\+into}} (self, src, dst)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


Definition at line 111 of file array.\+py.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classparla_1_1common_1_1array_1_1CupyArray_a215aed18e367dc2bd33c2d7acee29d2b}\label{classparla_1_1common_1_1array_1_1CupyArray_a215aed18e367dc2bd33c2d7acee29d2b}} 
\index{parla.common.array.CupyArray@{parla.common.array.CupyArray}!can\_assign\_from@{can\_assign\_from}}
\index{can\_assign\_from@{can\_assign\_from}!parla.common.array.CupyArray@{parla.common.array.CupyArray}}
\doxysubsubsection{\texorpdfstring{can\_assign\_from()}{can\_assign\_from()}}
{\footnotesize\ttfamily def parla.\+common.\+array.\+Cupy\+Array.\+can\+\_\+assign\+\_\+from (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{src,  }\item[{}]{dst }\end{DoxyParamCaption})}

\begin{DoxyVerb}:param a: An array of self's type.
:param b: An array of any type.
:return: True iff `a` supports assignments from `b`.
\end{DoxyVerb}
 

Reimplemented from \mbox{\hyperlink{classparla_1_1common_1_1array_1_1ArrayType_aa9fbf7d04f1c4b57fa19aae086941219}{parla.\+common.\+array.\+Array\+Type}}.



Definition at line 113 of file array.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{113     \textcolor{keyword}{def }\mbox{\hyperlink{namespaceparla_1_1common_1_1array_ab049a1a648a55658cbb087592d89e999}{can\_assign\_from}}(self, src, dst):}
\DoxyCodeLine{114         \textcolor{keywordflow}{return} isinstance(src, cupy.ndarray) \textcolor{keywordflow}{and} (src.device.id == dst.device.id)}
\DoxyCodeLine{115 }

\end{DoxyCode}


Referenced by parla.\+common.\+array.\+Numpy\+Array.\+copy\+\_\+into(), and parla.\+common.\+array.\+Cupy\+Array.\+copy\+\_\+into().

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1array_1_1CupyArray_a215aed18e367dc2bd33c2d7acee29d2b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classparla_1_1common_1_1array_1_1CupyArray_a1edea9230a248ec1b62fbec90c0bba92}\label{classparla_1_1common_1_1array_1_1CupyArray_a1edea9230a248ec1b62fbec90c0bba92}} 
\index{parla.common.array.CupyArray@{parla.common.array.CupyArray}!copy\_from@{copy\_from}}
\index{copy\_from@{copy\_from}!parla.common.array.CupyArray@{parla.common.array.CupyArray}}
\doxysubsubsection{\texorpdfstring{copy\_from()}{copy\_from()}}
{\footnotesize\ttfamily def parla.\+common.\+array.\+Cupy\+Array.\+copy\+\_\+from (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{src,  }\item[{int}]{target\+\_\+device\+\_\+id }\end{DoxyParamCaption})}

\begin{DoxyVerb}:param a: An array of some type.
:return: A copy of `a` of this type
\end{DoxyVerb}
 

Reimplemented from \mbox{\hyperlink{classparla_1_1common_1_1array_1_1ArrayType_ab42d664db67cf4c2e4260b295ef57331}{parla.\+common.\+array.\+Array\+Type}}.



Definition at line 119 of file array.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{119     \textcolor{keyword}{def }copy\_from(self, src, target\_device\_id: int):}
\DoxyCodeLine{120 }
\DoxyCodeLine{121         current\_context = \mbox{\hyperlink{namespaceparla_1_1common_1_1globals_a984f8b4c44f904aec08e3fe4cbcab416}{get\_current\_context}}()}
\DoxyCodeLine{122         current\_device = current\_context.devices[0]}
\DoxyCodeLine{123 }
\DoxyCodeLine{124         is\_gpu = (current\_device.architecture == DeviceType.CUDA)}
\DoxyCodeLine{125 }
\DoxyCodeLine{126         \textcolor{keywordflow}{if} isinstance(src, cupy.ndarray) \textcolor{keywordflow}{or} isinstance(src, numpy.ndarray):}
\DoxyCodeLine{127 }
\DoxyCodeLine{128             \textcolor{keywordflow}{if} isinstance(src, cupy.ndarray) \textcolor{keywordflow}{and} (src.device.id == target\_device\_id):}
\DoxyCodeLine{129                 \textcolor{comment}{\# Do not perform a copy if the array is already on the current device.}}
\DoxyCodeLine{130                 \textcolor{keywordflow}{return} src}
\DoxyCodeLine{131 }
\DoxyCodeLine{132             \textcolor{keywordflow}{if} src.flags[\textcolor{stringliteral}{'C\_CONTIGUOUS'}] \textcolor{keywordflow}{or} src.flags[\textcolor{stringliteral}{'F\_CONTIGUOUS'}]:}
\DoxyCodeLine{133 }
\DoxyCodeLine{134                 \textcolor{keyword}{with} cupy.cuda.Device(target\_device\_id) \textcolor{keyword}{as} d:}
\DoxyCodeLine{135                     stream = cupy.cuda.Stream(non\_blocking=\textcolor{keyword}{True})}
\DoxyCodeLine{136                     event = cupy.cuda.Event()}
\DoxyCodeLine{137 }
\DoxyCodeLine{138                     \textcolor{keyword}{with} stream \textcolor{keyword}{as} s:}
\DoxyCodeLine{139                         dst = cupy.empty\_like(src)}
\DoxyCodeLine{140 }
\DoxyCodeLine{141                     \textcolor{keywordflow}{if} is\_gpu:}
\DoxyCodeLine{142                         event.record(stream)}
\DoxyCodeLine{143                         \textcolor{keyword}{with} current\_device:}
\DoxyCodeLine{144                             target\_stream = cupy.cuda.get\_current\_stream()}
\DoxyCodeLine{145                             target\_stream.wait\_event(event)}
\DoxyCodeLine{146 }
\DoxyCodeLine{147                             memptr = src.data \textcolor{keywordflow}{if} isinstance(}
\DoxyCodeLine{148                                 src, cupy.ndarray) \textcolor{keywordflow}{else} src.ctypes.data}
\DoxyCodeLine{149                             dst.data.copy\_from\_async(}
\DoxyCodeLine{150                                 memptr, src.nbytes, stream=target\_stream)}
\DoxyCodeLine{151                     \textcolor{keywordflow}{else}:}
\DoxyCodeLine{152                         memptr = src.data \textcolor{keywordflow}{if} isinstance(}
\DoxyCodeLine{153                             src, cupy.ndarray) \textcolor{keywordflow}{else} src.ctypes.data}
\DoxyCodeLine{154                         dst.data.copy\_from\_async(}
\DoxyCodeLine{155                             memptr, src.nbytes, stream=stream)}
\DoxyCodeLine{156                         stream.synchronize()}
\DoxyCodeLine{157 }
\DoxyCodeLine{158                 \textcolor{keywordflow}{return} dst}
\DoxyCodeLine{159 }
\DoxyCodeLine{160             \textcolor{keywordflow}{if} isinstance(src, cupy.ndarray):}
\DoxyCodeLine{161                 \textcolor{keyword}{with} cupy.cuda.Device(src.device.id):}
\DoxyCodeLine{162                     src = cupy.ascontiguousarray(src)}
\DoxyCodeLine{163 }
\DoxyCodeLine{164             \textcolor{keyword}{with} cupy.cuda.Device(target\_device\_id):}
\DoxyCodeLine{165                 dst = cupy.asarray(src)}
\DoxyCodeLine{166 }
\DoxyCodeLine{167             \textcolor{keywordflow}{return} dst}
\DoxyCodeLine{168 }
\DoxyCodeLine{169         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{170             \textcolor{keywordflow}{raise} NotImplementedError(}
\DoxyCodeLine{171                 \textcolor{stringliteral}{"{}Non-\/ndarray types are not currently supported"{}})}
\DoxyCodeLine{172 }

\end{DoxyCode}


References parla.\+common.\+globals.\+get\+\_\+current\+\_\+context().



Referenced by parla.\+common.\+array.\+Numpy\+Array.\+copy\+\_\+into(), and parla.\+common.\+array.\+Cupy\+Array.\+copy\+\_\+into().

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1array_1_1CupyArray_a1edea9230a248ec1b62fbec90c0bba92_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1array_1_1CupyArray_a1edea9230a248ec1b62fbec90c0bba92_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classparla_1_1common_1_1array_1_1CupyArray_a85d9d51515a3ea45a322b92dbc22238f}\label{classparla_1_1common_1_1array_1_1CupyArray_a85d9d51515a3ea45a322b92dbc22238f}} 
\index{parla.common.array.CupyArray@{parla.common.array.CupyArray}!copy\_into@{copy\_into}}
\index{copy\_into@{copy\_into}!parla.common.array.CupyArray@{parla.common.array.CupyArray}}
\doxysubsubsection{\texorpdfstring{copy\_into()}{copy\_into()}}
{\footnotesize\ttfamily def parla.\+common.\+array.\+Cupy\+Array.\+copy\+\_\+into (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{src,  }\item[{}]{dst }\end{DoxyParamCaption})}

\begin{DoxyVerb}:param src: An array of some type.
:param dst: An array of this type.
:return: A copy of `src` into `dst`.
\end{DoxyVerb}
 

Reimplemented from \mbox{\hyperlink{classparla_1_1common_1_1array_1_1ArrayType_ac113bf53b87a75c444fde8cf763c4732}{parla.\+common.\+array.\+Array\+Type}}.



Definition at line 173 of file array.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{173     \textcolor{keyword}{def }copy\_into(self, src, dst):}
\DoxyCodeLine{174 }
\DoxyCodeLine{175         \textcolor{comment}{\# TODO: Add contiguous copy into memory buffer directly}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177         \textcolor{keywordflow}{if} self.can\_assign\_from(src, dst):}
\DoxyCodeLine{178             \textcolor{comment}{\# FIXME: When is this guaranteed to work for src/dst on different devices}}
\DoxyCodeLine{179             \textcolor{comment}{\# Strided access seems to fail (sometimes) on Peer access.}}
\DoxyCodeLine{180             \textcolor{keyword}{with} cupy.cuda.Device(dst.device.id):}
\DoxyCodeLine{181                 dst[:] = src}
\DoxyCodeLine{182         \textcolor{keywordflow}{elif} isinstance(src, numpy.ndarray) \textcolor{keywordflow}{or} isinstance(src, cupy.ndarray):}
\DoxyCodeLine{183             temp = self.copy\_from(src, dst.device.id)}
\DoxyCodeLine{184             \textcolor{keyword}{with} cupy.cuda.Device(dst.device.id):}
\DoxyCodeLine{185                 dst[:] = temp}
\DoxyCodeLine{186                 \textcolor{comment}{\# FIXME: What stream should we use here? How can we synchronize reliably?}}
\DoxyCodeLine{187         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{188             \textcolor{keywordflow}{raise} NotImplementedError(}
\DoxyCodeLine{189                 \textcolor{stringliteral}{"{}Non-\/ndarray types are not currently supported"{}})}
\DoxyCodeLine{190 }
\DoxyCodeLine{191 }
\DoxyCodeLine{192 \textcolor{comment}{\# FIXME: Put this in a better place.}}
\DoxyCodeLine{193 \_array\_types: Dict[type, ArrayType] = dict()}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 }

\end{DoxyCode}


References parla.\+common.\+array.\+Array\+Type.\+can\+\_\+assign\+\_\+from(), parla.\+common.\+array.\+Numpy\+Array.\+can\+\_\+assign\+\_\+from(), parla.\+common.\+array.\+Cupy\+Array.\+can\+\_\+assign\+\_\+from(), parla.\+common.\+array.\+Array\+Type.\+copy\+\_\+from(), parla.\+common.\+array.\+Numpy\+Array.\+copy\+\_\+from(), and parla.\+common.\+array.\+Cupy\+Array.\+copy\+\_\+from().

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classparla_1_1common_1_1array_1_1CupyArray_a85d9d51515a3ea45a322b92dbc22238f_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classparla_1_1common_1_1array_1_1CupyArray_a05613760234518c4446c79c14dfa6fd9}\label{classparla_1_1common_1_1array_1_1CupyArray_a05613760234518c4446c79c14dfa6fd9}} 
\index{parla.common.array.CupyArray@{parla.common.array.CupyArray}!get\_array\_module@{get\_array\_module}}
\index{get\_array\_module@{get\_array\_module}!parla.common.array.CupyArray@{parla.common.array.CupyArray}}
\doxysubsubsection{\texorpdfstring{get\_array\_module()}{get\_array\_module()}}
{\footnotesize\ttfamily def parla.\+common.\+array.\+Cupy\+Array.\+get\+\_\+array\+\_\+module (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{src }\end{DoxyParamCaption})}

\begin{DoxyVerb}:param a: An array of self's type.
:return: The `numpy` compatible module for the array `a`.
\end{DoxyVerb}
 

Reimplemented from \mbox{\hyperlink{classparla_1_1common_1_1array_1_1ArrayType_aac9efddb34176f9968b62fe61f311087}{parla.\+common.\+array.\+Array\+Type}}.



Definition at line 116 of file array.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{116     \textcolor{keyword}{def }\mbox{\hyperlink{namespaceparla_1_1common_1_1array_afde400cdbd0def19ac9250f756bd526b}{get\_array\_module}}(self, a):}
\DoxyCodeLine{117         \textcolor{keywordflow}{return} cupy}
\DoxyCodeLine{118 }

\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/python/parla/common/\mbox{\hyperlink{array_8py}{array.\+py}}\end{DoxyCompactItemize}
