Current implementation:

0. hw topology
1. task creation with configuration
2. data movement task
3. task execution moves time forward
4. task completion registers 

Necessary features:

0. need to define how scheduler on simulator works
- moving static number of tasks to the next phase
  (e.g., scheduler can process X tasks per Y microseconds)
  - the number of tasks to be moved could be from the actual throughput
  - or just follow user parameters
  - or make stochastic environment (which may be more practical)

1. more detail scenario in terms of scheduler:
- all tasks are spawned at the beginning
- some set of tasks in mappable are mapped to device (greedy or rl, for replaying)
  - the order of mappable tasks could be random or fixed if replaying mode is set
  - can limit the number of task mapping; could be user parameter or stochatic
- some set of tasks in mapped can reserve resources if their parents have reserved
  - also can limit the number of task reservation; colud be user parameter or stochatic
- ready tasks are tasks which have reserved resource and all parents have done.
  - not limit the number of tasks to be processed at this phase

2. code structure:

timestep = 0
while True:
  timestep += 1
  for t in running_tasks:
    t.update_time(timestep) # could be completed and notify childs
  scheduler.process(t)


...


class scheduler:
  ..
  def process(t):
    update_time(t)
    check_mappable_task()
    mapping()
    reservation()
    launching()

  def check_mappable_task():
    num_tasks_become_mappable = 0
    for t in created_task()
      if t's parent are all mapped:
        if stochastic_mode:
          if randomly_decide_do_or_not():
            update_task_to_mappable(t)
        else:
          if num_tasks_become_mappable < threshold:
            update_task_to_mappable(t)
          else:
            break

  def mapping():
    num_tasks_become_mapped = 0
    for t in mappable_task()
      if stochastic_mode:
        if randomly_decide_do_or_not():
          map_task(t)
      else:
        if num_tasks_become_mapped < threshold:
          update_task_to_mapped(t)
        else:
          break

  ...

